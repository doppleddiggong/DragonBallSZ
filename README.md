# DragonBallSZ: A C++ UE5 Replica of "Sparking! Zero"

[![Unreal Engine](https://img.shields.io/badge/Unreal%20Engine-5.6.0-blue.svg)](https://www.unrealengine.com/)
[![Language](https://img.shields.io/badge/C%2B%2B-20-blue.svg)](https://isocpp.org/)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)

> **이 프로젝트는 '드래곤볼 스파킹 제로'의 핵심 전투 시스템을 언리얼 엔진 5와 C++를 사용하여 깊이 있게 재구현한 기술 중심의 개인 포트폴리오입니다.**


![Game Title](https://github.com/doppleddiggong/DragonBallSZ/blob/main/Documents/Reference/GameTitle.jpg?raw=true)


## 📜 1. 프로젝트 소개

`DragonBallSZ`는 원작의 상징적인 3D 공간 전투를 기술적으로 재해석하는 데 중점을 둔 프로젝트입니다. 단순한 외형 복제를 넘어, C++ 기반의 견고한 아키텍처 위에서 **빠른 반응성, 높은 확장성, 데이터 기반의 유연성**을 갖춘 시스템을 구축하는 것을 목표로 삼았습니다.

이 문서는 프로젝트의 핵심 기능뿐만 아니라, 적용된 **프로그래밍 기법, 아키텍처 설계, 그리고 단계별 개발 과정**을 상세히 기술하여 기술적 성취를 공유하고자 합니다.

## ✨ 2. 핵심 기능 상세

### 2.1. 데이터 기반 설계 (Data-Driven Design)

- **구현 방식 (How):**
  - `UDBSZDataManager`라는 중앙 관리 서브시스템을 구현하여, 게임 시작 시 CSV 파일로부터 `UDataTable` 애셋들을 로드하고 캐싱합니다.
  - 캐릭터 스탯, 스킬 정보, 넉백 강도, 히트스탑 시간 등 게임의 모든 수치적 요소를 데이터 테이블(`FCharacterStatData`, `FKnockbackData`, `FHitStopData` 등)로 분리했습니다.
  - 나이아가라 이펙트와 사운드 역시 `UVFXDataAsset`과 같은 데이터 애셋을 통해 게임플레이 태그(`FGameplayTag`)와 매핑하여, 코드 변경 없이 리소스를 교체할 수 있도록 설계했습니다.

- **사용 목적 (Why):**
  - **신속한 이터레이션**: 프로그래머의 개입 없이 기획자가 직접 CSV 파일을 수정하는 것만으로 게임 밸런스(캐릭터 공격력, 스킬 쿨다운 등)와 전투의 타격감(히트스탑 시간, 넉백 거리)을 실시간으로 조율할 수 있습니다.
  - **유지보수성**: 게임 로직과 데이터를 명확히 분리하여 코드의 복잡도를 낮추고, 버그 발생 시 원인 파악을 용이하게 합니다.

### 2.2. C++ 컴포넌트 기반 전투 시스템

- **구현 방식 (How):**
  - 플레이어와 AI의 공통 기반이 되는 `ACombatCharacter` 클래스를 만들고, 모든 전투 관련 기능을 각각의 `UActorComponent`로 모듈화했습니다.
    - `UStatSystem`: 캐릭터의 HP, Ki 등 모든 스탯과 콤보 카운터를 관리합니다.
    - `UDashSystem` / `UFlySystem`: `UCharacterMovementComponent`를 제어하여 고속 이동과 자유로운 비행을 구현합니다.
    - `URushAttackSystem`: 단일 애니메이션 몽타주와 루트 모션을 기반으로, 여러 번의 순간이동과 공격을 연계하는 복잡한 시퀀스를 관리합니다.
  - 각 컴포넌트는 독립적으로 동작하며, `ACombatCharacter`는 이들을 조합하여 전투 능력을 갖추게 됩니다.

- **사용 목적 (Why):**
  - **확장성 및 재사용성**: 새로운 캐릭터나 몬스터를 추가할 때, 필요한 기능의 컴포넌트만 조합하여 쉽게 새로운 타입을 만들 수 있습니다.
  - **관심사 분리 (Separation of Concerns)**: 각 시스템이 명확한 책임(이동, 공격, 스탯 등)을 가지므로 코드를 이해하고 수정하기 용이합니다.

### 2.3. 지능형 AI (FSM 기반)

- **구현 방식 (How):**
  - 적 AI의 두뇌 역할을 하는 `UEnemyFSM` 컴포넌트를 구현했습니다. 이 컴포넌트는 `EEnemyState` 열거형(대기, 추격, 근접 공격, 원거리 공격, 방어, 스킬 사용 등)에 따라 행동을 결정하는 Finite State Machine으로 동작합니다.
  - `UAIPerceptionComponent`를 활용한 `USightSystem`으로 플레이어를 감지하고, FSM은 플레이어와의 거리, 자신의 HP 상태 등을 조건으로 상태를 전환(Transition)합니다.
  - 예를 들어, 플레이어와 멀리 떨어져 있으면 '원거리 공격' 상태로, 가까워지면 '근접 공격' 또는 '추격' 상태로 전환됩니다.

- **사용 목적 (Why):**
  - **예측 가능하고 도전적인 행동**: AI가 정해진 규칙에 따라 행동하므로 플레이어는 AI의 패턴을 학습하고 대응하는 전략적인 재미를 느낄 수 있습니다.
  - **쉬운 디버깅 및 확장**: 상태 기반 설계는 AI의 현재 행동 이유를 명확히 알 수 있게 해주며, 새로운 행동(예: '회피' 상태)을 추가하기도 용이합니다.

### 2.4. 다이내믹 연출 시스템 (VFX & Camera)

- **구현 방식 (How):**
  - **VFX**: `UDBSZVFXManager` 서브시스템이 데이터 애셋에 정의된 VFX를 전투 상황(타격, 대시, 스킬 시전)에 맞게 월드에 스폰하고 관리합니다. C++ 코드는 게임플레이 이벤트만 발생시키고, 어떤 이펙트를 어디에 출력할지는 데이터가 결정합니다.
  - **Camera**: `ACameraManager`를 상속받아, `HitStop` 발생 시 `SetGlobalTimeDilation`과 함께 카메라 셰이크와 FOV(시야각)를 조절하는 함수를 추가했습니다. 필살기 시전 시에는 특정 시네마틱 시퀀스 애셋을 재생하도록 하여 연출을 극대화했습니다.

- **사용 목적 (Why):**
  - **몰입감 극대화**: 정적인 전투가 아닌, 상황에 따라 시각 효과와 카메라 워크가 역동적으로 변화하여 플레이어가 전투의 중심에 있는 듯한 몰입감을 제공합니다.
  - **연출과 로직의 분리**: 전투 로직 코드의 변경 없이, 데이터와 시퀀스 애셋 수정만으로 다양한 시네마틱 연출을 테스트하고 적용할 수 있습니다.

## 📈 3. 개발 과정 요약

- **Phase 1: 프로토타입 (기술 기반 구축)**
  - C++ 중심의 전투 아키텍처를 설계하고, 비행/대시/돌진 공격 등 핵심 메커니즘의 프로토타입을 구현하여 기술적 가능성을 검증했습니다.

- **Phase 2: 알파 (핵심 재미 구체화)**
  - 상징적인 필살기 '에네르기파'를 구현하고, 기 충전, 콤보 시스템 등 전투의 깊이를 더하는 시스템을 추가했습니다. UI/사운드 피드백을 강화하여 플레이 경험을 구체화했습니다.

- **Phase 3: 베타 & 폴리싱 (완성도 및 확장성 확보)**
  - 캐릭터 선택 시스템을 도입하여 다중 캐릭터의 기반을 마련하고, Tick 최적화 등 성능 개선에 집중했습니다. 게임패드를 지원하고 전반적인 버그를 수정하며 안정성을 확보했습니다.

## 📑 4. 단계별 상세 개발 내용

### 4.1. Phase 1: 프로토타입 (2025.09 초)
- **목표**: 핵심 전투 시스템의 기술적 가능성 검증
- **주요 개발 내용**:
  - `ACombatCharacter` 중심의 전투 컴포넌트 아키텍처 설계
  - 비행(`UFlySystem`) 및 대시(`UDashSystem`) 기본 이동 시스템 구현
  - `RushAttack` 및 에너지탄(`AEnergyBlastActor`) 프로토타입 개발
  - 데이터 기반 시스템(`UDBSZDataManager`, `UVFXData`)의 기반 마련

### 4.2. Phase 2: 알파 (2025.09 중)
- **목표**: 핵심 기능 구체화 및 콘텐츠 확장
- **주요 개발 내용**:
  - **`Kamehameha` 시스템**: 기 소모, 발사 시퀀스, 나이아가라 VFX 연동 구현
  - **전투 시스템 고도화**: 기 충전 시스템, 콤보 카운터, 대미지 랜덤성 추가
  - **UI/UX 피드백**: 전투 UI에 대미지, 콤보, 시간 표시 기능 추가
  - **사운드 시스템**: 주요 액션에 효과음(SFX)을 연동하여 타격감 강화

### 4.3. Phase 3: 베타 & 폴리싱 (2025.09 말)
- **목표**: 기능 완성, 성능 최적화, 안정성 확보
- **주요 개발 내용**:
  - **캐릭터 선택 시스템**: `UCharacterSelectManager`를 통한 C++ 기반 캐릭터 선택/로드 기능 구현
  - **성능 최적화**: 캐릭터 및 AI 컴포넌트의 Tick 사용량 최적화
  - **리팩토링**: 러시 어택 시스템을 단일 몽타주 기반으로 개선, `TObjectPtr` 적용
  - **플랫폼 확장**: 게임패드(듀얼쇼크) 입력 지원 추가
  - **아트 폴리싱**: `Kamehameha` 시네마틱 연출 강화, 대시 VFX 개선, UI 디자인 개선

## 🚀 5. 빌드 및 실행

1.  **전제 조건**: Visual Studio 2022와 Unreal Engine 5.6.0 설치
2.  프로젝트 루트에서 `DragonBallSZ.uproject` 파일을 우클릭하여 "Generate Visual Studio project files" 실행
3.  생성된 `DragonBallSZ.sln` 파일을 Visual Studio 또는 Rider로 열기
4.  `DragonBallSZEditor`를 빌드 타겟으로 설정하고 컴파일
5.  언리얼 에디터에서 프로젝트 실행
